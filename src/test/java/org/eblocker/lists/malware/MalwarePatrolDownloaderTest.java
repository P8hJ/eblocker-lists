/*
 * Copyright 2020 eBlocker Open Source UG (haftungsbeschraenkt)
 *
 * Licensed under the EUPL, Version 1.2 or - as soon they will be
 * approved by the European Commission - subsequent versions of the EUPL
 * (the "License"); You may not use this work except in compliance with
 * the License. You may obtain a copy of the License at:
 *
 *   https://joinup.ec.europa.eu/page/eupl-text-11-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package org.eblocker.lists.malware;

import org.eblocker.server.common.malware.MalwareEntry;
import org.eblocker.lists.util.HttpClient;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import javax.xml.bind.DatatypeConverter;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.List;
import java.util.Properties;
import java.util.Random;

public class MalwarePatrolDownloaderTest {

    private static final String USERNAME = "username";
    private static final String PASSWORD = "password";
    private static final String URL = "https://test.com/malware.txt";
    private static final String MD5_URL = "https://test.com/malware.txt.md5";
    private static final String SHA1_URL = "https://test.com/malware.txt.sha1";

    private List<MalwareEntry> entries;
    private HttpClient httpClient;
    private MalwarePatrolDownloader downloader;

    @Before
    public void setUp() throws IOException {
        Properties properties = new Properties();
        properties.put("provider.malwarepatrol.auth.username", USERNAME);
        properties.put("provider.malwarepatrol.auth.password", PASSWORD);
        properties.put("provider.malwarepatrol.malware.url", URL);
        properties.put("provider.malwarepatrol.malware.md5.url", MD5_URL);
        properties.put("provider.malwarepatrol.malware.sha1.url", SHA1_URL);

        byte[] malwareContent = new byte[65536];
        new Random().nextBytes(malwareContent);
        String md5 = DatatypeConverter.printHexBinary(checksum("md5", malwareContent));
        String sha1 = DatatypeConverter.printHexBinary(checksum("sha1", malwareContent));

        httpClient = Mockito.mock(HttpClient.class);
        Mockito.when(httpClient.download(URL, USERNAME, PASSWORD)).thenReturn(new ByteArrayInputStream(malwareContent));
        Mockito.when(httpClient.download(MD5_URL, USERNAME, PASSWORD)).thenReturn(new ByteArrayInputStream(md5.getBytes()));
        Mockito.when(httpClient.download(SHA1_URL, USERNAME, PASSWORD)).thenReturn(new ByteArrayInputStream(sha1.getBytes()));

        entries = Mockito.mock(List.class);
        MalwarePatrolSanitizedUrlsParser parser = Mockito.mock(MalwarePatrolSanitizedUrlsParser.class);
        Mockito.when(parser.parse(Mockito.any(InputStream.class))).thenReturn(entries);

        downloader = new MalwarePatrolDownloader(httpClient, parser, properties);
    }

    @Test
    public void retrieveEntries() throws IOException, MalwareListException {
        List<MalwareEntry> entries = downloader.retrieveEntries();
        Assert.assertTrue(this.entries == entries);
        Mockito.verify(httpClient).download(URL, USERNAME, PASSWORD);
        Mockito.verify(httpClient).download(MD5_URL, USERNAME, PASSWORD);
        Mockito.verify(httpClient).download(SHA1_URL, USERNAME, PASSWORD);
    }

    @Test(expected = MalwarePatrolDownloader.ChecksumException.class)
    public void retrieveEntriesChecksumMismatchMd5() throws IOException, MalwareListException {
        Mockito.when(httpClient.download(MD5_URL, USERNAME, PASSWORD)).thenReturn(new ByteArrayInputStream("00000000000000000000000000000000".getBytes()));
        downloader.retrieveEntries();
    }

    @Test(expected = MalwarePatrolDownloader.ChecksumException.class)
    public void retrieveEntriesChecksumMismatchSha1() throws IOException, MalwareListException {
        Mockito.when(httpClient.download(SHA1_URL, USERNAME, PASSWORD)).thenReturn(new ByteArrayInputStream("0000000000000000000000000000000000000000".getBytes()));
        downloader.retrieveEntries();
    }

    @Test(expected = IOException.class)
    public void retrieveEntriesDownloadError() throws IOException, MalwareListException {
        Mockito.when(httpClient.download(URL, USERNAME, PASSWORD)).thenThrow(IOException.class);
        downloader.retrieveEntries();
    }

    private byte[] checksum(String algorithm, byte[] data) {
        try {
            return MessageDigest.getInstance(algorithm).digest(data);
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalArgumentException("unsupported message digest " + algorithm, e);
        }
    }
}