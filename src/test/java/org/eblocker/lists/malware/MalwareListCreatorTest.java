/*
 * Copyright 2020 eBlocker Open Source UG (haftungsbeschraenkt)
 *
 * Licensed under the EUPL, Version 1.2 or - as soon they will be
 * approved by the European Commission - subsequent versions of the EUPL
 * (the "License"); You may not use this work except in compliance with
 * the License. You may obtain a copy of the License at:
 *
 *   https://joinup.ec.europa.eu/page/eupl-text-11-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package org.eblocker.lists.malware;

import org.eblocker.server.common.malware.MalwareEntry;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

public class MalwareListCreatorTest {

    private Properties properties;
    private ObjectMapper objectMapper;

    private Path outputUrls;
    private Path outputIpPorts;

    @Before
    public void setup() throws IOException {
        outputUrls = Files.createTempFile("malware-urls", ",json");
        outputIpPorts = Files.createTempFile("malware-ipPorts", ",json");

        properties = new Properties();
        properties.setProperty("output.filtered.urls", outputUrls.toString());
        properties.setProperty("output.filtered.ipPorts", outputIpPorts.toString());

        objectMapper = new ObjectMapper();
    }

    @After
    public void tearDown() throws IOException {
        Files.deleteIfExists(outputUrls);
        Files.deleteIfExists(outputIpPorts);
    }

    @Test
    public void test() throws MalwareListException, IOException {
        Map<String, Set<Integer>> ipPortsA = new HashMap<>();
        ipPortsA.put("1.1.1.1", set(8080));
        ipPortsA.put("2.2.2.2", set(8443));
        MalwareEntries entriesA = new MalwareEntries(Arrays.asList(
                new MalwareEntry("host.com", new String[] { "malware" }),
                new MalwareEntry("host.net", new String[] { "malware" })),
                ipPortsA);

        Map<String, Set<Integer>> ipPortsB = new HashMap<>();
        ipPortsB.put("1.1.1.1", set(8000));
        ipPortsB.put("3.3.3.3", set(7999));
        MalwareEntries entriesB = new MalwareEntries(Arrays.asList(
                new MalwareEntry("host.com", new String[] { "malware2" }),
                new MalwareEntry("host.org", new String[] { "malware2" })),
                ipPortsB);

        MalwareListCreator creator = new MalwareListCreator(properties, objectMapper, Arrays.asList(
                new TestProvider(entriesA),
                new TestProvider(entriesB)));

        creator.run();

        Assert.assertTrue(Files.exists(outputUrls));
        List<MalwareEntry> entries = objectMapper.readValue(Files.newInputStream(outputUrls), new TypeReference<List<MalwareEntry>>(){});
        Collections.sort(entries, Comparator.comparing(MalwareEntry::getUrl));
        Assert.assertEquals(3, entries.size());
        Assert.assertEquals("host.com", entries.get(0).getUrl());
        Assert.assertEquals(set("malware", "malware2"), set(entries.get(0).getHostedMalware()));
        Assert.assertEquals("host.net", entries.get(1).getUrl());
        Assert.assertEquals(set("malware"), set(entries.get(1).getHostedMalware()));
        Assert.assertEquals("host.org", entries.get(2).getUrl());
        Assert.assertEquals(set("malware2"), set(entries.get(2).getHostedMalware()));

        Assert.assertTrue(Files.exists(outputIpPorts));
        Map<String, Set<Integer>> ipPorts = objectMapper.readValue(Files.newInputStream(outputIpPorts), new TypeReference<Map<String, Set<Integer>>>(){});
        Assert.assertEquals(3, ipPorts.size());
        Assert.assertEquals(set(8080, 8000), ipPorts.get("1.1.1.1"));
        Assert.assertEquals(ipPortsA.get("2.2.2.2"), ipPorts.get("2.2.2.2"));
        Assert.assertEquals(ipPortsB.get("3.3.3.3"), ipPorts.get("3.3.3.3"));
    }

    @Test(expected = MalwareListException.class)
    public void testProviderException() throws MalwareListException {
        MalwareListCreator creator = new MalwareListCreator(properties, objectMapper, Collections.singletonList(() -> { throw new MalwareListException("test"); }));
        creator.run();
    }

    private class TestProvider implements MalwareProvider {
        private MalwareEntries entries;

        public TestProvider(MalwareEntries entries) {
            this.entries = entries;
        }

        @Override
        public MalwareEntries getMalwareEntries() throws MalwareListException {
            return entries;
        }
    }

    private <T> Set<T> set(T... values) {
        Set<T> set = new HashSet<>();
        for (T v : values) {
            set.add(v);
        }
        return set;
    }
}