package org.eblocker.lists.malware;

import org.eblocker.server.common.malware.MalwareEntry;
import org.eblocker.server.common.util.IpUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Extracts hosts with non-standard ports from URLs and resolves these hosts to IP addresses.
 */
public class IpPortExtractor {
    private static final Logger log = LoggerFactory.getLogger(IpPortExtractor.class);

    private static final Pattern hostPortPattern = Pattern.compile("^([^:/]*):(\\d+)");
    private static final Pattern ipv6PortPattern = Pattern.compile("^\\[([a-f0-9:]+)\\]:(\\d+)", Pattern.CASE_INSENSITIVE);

    private final DnsResolverService dnsResolverService;

    public IpPortExtractor(DnsResolverService dnsResolverService) {
        this.dnsResolverService = dnsResolverService;
    }

    public Map<String, Set<Integer>> getIpsAndNonStandPorts(List<MalwareEntry> entries) throws NameResolutionException {
        Map<Boolean, List<HostPortTuple>> hosts = entries.stream()
            .map(e -> getHostWithNonStandardPort(e.getUrl()))
            .filter(Objects::nonNull)
            .distinct()
            .collect(Collectors.groupingBy(t -> IpUtils.isIPAddress(t.host)));
        hosts.putIfAbsent(false, Collections.emptyList());
        hosts.putIfAbsent(true, Collections.emptyList());

        log.info("{} out of {} entries use non-standard port", hosts.get(false).size() + hosts.get(true).size(), entries.size());
        log.info("{} entries needs to be resolved", hosts.get(false).size());

        List<HostPortTuple> unresolved = hosts.get(false);
        Collection<HostPortTuple> resolved = dnsResolverService.resolveHosts(unresolved);

        return Stream.concat(hosts.get(true).stream(), resolved.stream())
            .collect(Collectors.groupingBy(t -> t.host))
            .entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                t -> t.getValue().stream()
                    .map(e -> e.port)
                    .collect(Collectors.toSet())));
    }

    /**
     * Extract host and port from a URL if a non-standard port is used.
     * IPv6 addresses must be enclosed in brackets [].
     * @param url the URL starting with the host, i.e. the protocol part is not included
     * @return HostPortTuple if the port is non-standard, otherwise null
     */
    public static HostPortTuple getHostWithNonStandardPort(String url) {
        String host;
        int port;
        Matcher matcher = ipv6PortPattern.matcher(url);
        if (matcher.find()) {
            host = matcher.group(1);
            port = Integer.parseInt(matcher.group(2));
        } else {
            matcher = hostPortPattern.matcher(url);
            if (matcher.find()) {
                host = matcher.group(1);
                port = Integer.parseInt(matcher.group(2));
            } else {
                return null;
            }
        }
        if (port != 80 && port != 443) {
            return new HostPortTuple(host, port);
        }
        return null;
    }
}
