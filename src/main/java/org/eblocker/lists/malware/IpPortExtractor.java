package org.eblocker.lists.malware;

import org.eblocker.server.common.malware.MalwareEntry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Extracts hosts with non-standard ports from URLs and resolves these hosts to IP addresses.
 */
public class IpPortExtractor {
    private static final Logger log = LoggerFactory.getLogger(IpPortExtractor.class);

    private static final Pattern hostPortPattern = Pattern.compile("^([^:/]*):(\\d+)");
    private static final Pattern IP_PATTERN = Pattern.compile("^\\d+\\.\\d+\\.\\d+\\.\\d+$");

    private final DnsResolverService dnsResolverService;

    public IpPortExtractor(DnsResolverService dnsResolverService) {
        this.dnsResolverService = dnsResolverService;
    }

    public Map<String, Set<Integer>> getIpsAndNonStandPorts(List<MalwareEntry> entries) throws NameResolutionException {
        Map<Boolean, List<HostPortTuple>> hosts = entries.stream()
            .map(e -> hostPortPattern.matcher(e.getUrl()))
            .filter(Matcher::find)
            .filter(m -> !"80".equals(m.group(2)) && !"443".equals(m.group(2)))
            .map(m -> new HostPortTuple(m.group(1), Integer.parseInt(m.group(2))))
            .distinct()
            .collect(Collectors.groupingBy(t -> IP_PATTERN.matcher(t.host).matches()));
        hosts.putIfAbsent(false, Collections.emptyList());
        hosts.putIfAbsent(true, Collections.emptyList());

        log.info("{} out of {} entries use non-standard port", hosts.get(false).size() + hosts.get(true).size(), entries.size());
        log.info("{} entries needs to be resolved", hosts.get(false).size());

        List<HostPortTuple> unresolved = hosts.get(false);
        Collection<HostPortTuple> resolved = dnsResolverService.resolveHosts(unresolved);

        return Stream.concat(hosts.get(true).stream(), resolved.stream())
            .collect(Collectors.groupingBy(t -> t.host))
            .entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                t -> t.getValue().stream()
                    .map(e -> e.port)
                    .collect(Collectors.toSet())));
    }
}
